package com.adp.autopay.cci.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class CciSecurity {
    
    private final DataSource dataSource;

    public CciSecurityBean login(String sUserId, String sPassword, DataSource dataSource1, 
                                boolean bUsesingleDataSource, String sDbName, String sDbSchema, 
                                boolean bTrace) throws CciLoginException {
        
        log.info("Attempting to log in user '{}'", sUserId);

        Connection connection = null;
        CallableStatement callableStatement = null;

        String sLSecurityData = "";
        int iLsRtnC = 3;
        String sLsErrorMsg1 = "";
        String sLsErrorMsg2 = "";
        String sLsErrorMsg3 = "";
        String sLsErrorMsg4 = "";

        int iRetryCount = 0;
        boolean bError = true;

        do {
            try {
                connection = dataSource1.getConnection();
                log.info("Successfully connected to database");
                
                String sSql;
                String safeDbName = sanitizeAlphaNum(sDbName, 16);
                String safeDbSchema = sanitizeAlphaNum(sDbSchema, 16);
                
                if (bUsesingleDataSource) {
                    sSql = "Call " + safeDbName + "." + safeDbSchema + ".PLSFAUTH(?,?,?,?,?,?,?)";
                } else {
                    sSql = "Call " + safeDbSchema + ".PLSFAUTH(?,?,?,?,?,?,?)";
                }
                
                log.info("sSql = {}", sSql);
                
                callableStatement = connection.prepareCall(sSql);
                callableStatement.setString(1, truncate(sUserId, 3));
                callableStatement.setString(2, truncate(sPassword, 10));
                callableStatement.registerOutParameter(3, Types.CHAR);
                callableStatement.registerOutParameter(4, Types.INTEGER);
                callableStatement.registerOutParameter(5, Types.CHAR);
                callableStatement.registerOutParameter(6, Types.CHAR);
                callableStatement.registerOutParameter(7, Types.CHAR);
                callableStatement.registerOutParameter(8, Types.CHAR);
                
                callableStatement.execute();
                
                sLSecurityData = callableStatement.getString(3);
                iLsRtnC = callableStatement.getInt(4);
                sLsErrorMsg1 = callableStatement.getString(5);
                sLsErrorMsg2 = callableStatement.getString(6);
                sLsErrorMsg3 = callableStatement.getString(7);
                sLsErrorMsg4 = callableStatement.getString(8);
                
                callableStatement.close();
                bError = false;
                
            } catch (SQLRecoverableException | SQLNonTransientConnectionException e) {
                iRetryCount++;
                if (iRetryCount > 2) {
                    throw new CciLoginException(CciLoginException.CLE_DB_ERROR,
                            "Stale Connection Exception calling PLSFAUTH", e.getMessage(), "", "", "");
                }
            } catch (SQLException e) {
                try {
                    if (callableStatement != null) callableStatement.close();
                    if (connection != null) connection.close();
                } catch (Exception ex) {
                    // ignore
                }
                throw new CciLoginException(CciLoginException.CLE_DB_ERROR,
                        "Call to stored procedure PLSFAUTH failed", e.getMessage(), "", "", "");
            } finally {
                try {
                    if (connection != null) connection.close();
                } catch (Exception e) {
                    log.info("Attempt to close database connection failed");
                }
            }
        } while (bError && iRetryCount < 3);

        log.info("Data returned from PLSFAUTH follows:");
        log.info("LsSecurityData = {}", sLSecurityData);
        log.info("ListRrc = {}", iLsRtnC);
        log.info("LsErrorMsg1 = {}", sLsErrorMsg1);
        log.info("LsErrorMsg2 = {}", sLsErrorMsg2);
        log.info("LsErrorMsg3 = {}", sLsErrorMsg3);
        log.info("LsErrorMsg4 = {}", sLsErrorMsg4);

        CciSecurityBean cciSecurityBean = new CciSecurityBean(sUserId);
        String sErrorMessage;

        switch (iLsRtnC) {
            case 0: // Success
                String sRfcAuthFlag = "N";
                if (sLSecurityData != null && sLSecurityData.length() > 0) {
                    sRfcAuthFlag = sLSecurityData.substring(3, 4);
                }
                
                if (sRfcAuthFlag.equalsIgnoreCase("Y")) {
                    log.info("RFC value for update access={}", sRfcAuthFlag);
                    cciSecurityBean.setIAuthLsfrs(CciSecurityBean.CCI_AUTH_UPDATE);
                } else {
                    log.info("RFC value for inquiry only access={}", sRfcAuthFlag);
                    cciSecurityBean.setIAuthLsfrs(CciSecurityBean.CCI_AUTH_INQUIRY);
                }
                break;
                
            case 1: // Database Error
                throw new CciLoginException(CciLoginException.CLE_DB_ERROR,
                        "Database Error in PLSFAUTH", sLsErrorMsg1, sLsErrorMsg2, sLsErrorMsg3, sLsErrorMsg4);
                        
            case 2: // Authentication Failed
                sErrorMessage = "User ID and/or Password invalid";
                log.info(sErrorMessage);
                throw new CciLoginException(CciLoginException.CLE_NOT_AUTHORIZED, 
                        sErrorMessage, sLsErrorMsg1, sLsErrorMsg2, sLsErrorMsg3, sLsErrorMsg4);
                        
            default:
                sErrorMessage = "Return code '" + iLsRtnC + "' from PLSFAUTH";
                throw new CciLoginException(CciLoginException.CLE_DB_ERROR, 
                        sErrorMessage, sLsErrorMsg1, sLsErrorMsg2, sLsErrorMsg3, sLsErrorMsg4);
        }
        
        return cciSecurityBean;
    }

    private String truncate(String sStringIn, int iLength) {
        if (sStringIn.length() > iLength) {
            return sStringIn.substring(0, iLength);
        }
        return sStringIn;
    }

    private String sanitizeAlphaNum(String sInput, int iMaxLen) {
        if (sInput == null) return null;
        String sSanitized = sInput.replaceAll("[^A-Za-z0-9_]", "");
        if (sSanitized.length() > iMaxLen) {
            sSanitized = sSanitized.substring(0, iMaxLen);
        }
        return sSanitized;
    }
}
